<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>ì—¬ë´‰ì´ ì˜¤ëª©</title>
  <style>
    :root{
      --bg:#0b0f19;
      --card:rgba(255,255,255,.08);
      --line:rgba(255,255,255,.14);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.62);
      --btn:rgba(255,255,255,.10);
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      background: radial-gradient(1200px 700px at 50% -100px, rgba(255,255,255,.14), transparent 65%),
                  radial-gradient(1000px 600px at 10% 110%, rgba(255,255,255,.10), transparent 60%),
                  var(--bg);
      color:var(--text);
    }
    .app{
      max-width:560px;
      margin:0 auto;
      padding:16px 14px 22px;
      display:flex;
      flex-direction:column;
      gap:12px;
      min-height:100vh;
    }
    .header{
      padding:14px 14px;
      border:1px solid var(--line);
      background:linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      border-radius:18px;
      box-shadow:0 10px 30px rgba(0,0,0,.25);
    }
    .topRow{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .title{ margin:0; font-size:18px; font-weight:900; letter-spacing:-.2px; }
    .sub{ margin:6px 0 0; font-size:12px; color:var(--muted); line-height:1.35; }
    .faces{ display:flex; align-items:center; gap:8px; flex-shrink:0; }
    .face{
      width:28px; height:28px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.25);
      background:rgba(255,255,255,.10);
      object-fit:cover;
    }
    .vs{ font-size:11px; color:var(--muted); font-weight:900; }

    .controls{ margin-top:12px; display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .btn{
      appearance:none;
      border:1px solid rgba(255,255,255,.18);
      background:var(--btn);
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      font-weight:900;
      font-size:13px;
      cursor:pointer;
      user-select:none;
      backdrop-filter: blur(8px);
    }
    .btn:active{ transform:translateY(1px); }
    .btn.primary{
      background:rgba(255,255,255,.92);
      color:#0b0f19;
      border-color:rgba(255,255,255,.92);
    }
    .chip{
      margin-left:auto;
      padding:9px 12px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.18);
      background:var(--card);
      font-size:12px;
      font-weight:900;
      color:var(--text);
      display:flex;
      align-items:center;
      gap:8px;
    }
    .dot{
      width:8px;height:8px;border-radius:999px;
      background:rgba(255,255,255,.85);
      box-shadow:0 0 0 4px rgba(255,255,255,.10);
    }

    .boardCard{
      border:1px solid var(--line);
      background:linear-gradient(180deg, rgba(255,255,255,.09), rgba(255,255,255,.05));
      border-radius:20px;
      padding:14px;
      box-shadow:0 12px 34px rgba(0,0,0,.28);
    }
    .boardWrap{ display:flex; align-items:center; justify-content:center; padding:6px; }
    canvas{
      width:min(94vw, 520px);
      height:min(94vw, 520px);
      border-radius:18px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.92);
      box-shadow:0 14px 28px rgba(0,0,0,.28);
      touch-action:none;
    }

    .footer{
      border:1px solid var(--line);
      background:var(--card);
      border-radius:18px;
      padding:12px 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .msg{ font-weight:900; font-size:13px; letter-spacing:-.1px; }
    .hint{ font-size:12px; color:var(--muted); font-weight:800; white-space:nowrap; }

    /* =========================
       âœ… íŒì—…(ëª¨ë‹¬)
       ========================= */
    .modal-backdrop{
      position:fixed; inset:0;
      background:rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
      padding:18px;
      z-index:9999;
    }
    .modal-backdrop.show{ display:flex; }
    .modal{
      width:min(420px, 92vw);
      border-radius:22px;
      border:1px solid rgba(255,255,255,.20);
      background:linear-gradient(180deg, rgba(255,255,255,.14), rgba(255,255,255,.08));
      box-shadow:0 22px 60px rgba(0,0,0,.55);
      padding:16px 16px 14px;
      backdrop-filter: blur(10px);
      transform: translateY(8px) scale(.98);
      opacity:.98;
      animation: pop .16s ease-out forwards;
    }
    @keyframes pop{
      to{ transform: translateY(0) scale(1); opacity:1; }
    }
    .modalTitle{
      margin:0;
      font-size:18px;
      font-weight:1000;
      letter-spacing:-.2px;
    }
    .modalDesc{
      margin:8px 0 0;
      font-size:12px;
      color:var(--muted);
      font-weight:800;
      line-height:1.45;
    }
    .modalBtns{
      display:flex;
      gap:8px;
      margin-top:14px;
    }
    .modalBtns .btn{ flex:1; justify-content:center; }
  </style>
</head>
<body>
  <div class="app">
    <div class="header">
      <div class="topRow">
        <div>
          <h1 class="title">ì—¬ë´‰ì´ ì˜¤ëª©</h1>
          <div class="sub">í•œ ë²ˆ ëˆŒëŸ¬ì„œ ëŒ ë†“ê¸° Â· 5ëª© ë¨¼ì € ë§Œë“¤ë©´ ìŠ¹ë¦¬</div>
        </div>
        <div class="faces" title="ëŒ ìŠ¤í‚¨">
          <img class="face" id="p1Face" alt="ì—¬ë´‰ì´" />
          <span class="vs">VS</span>
          <img class="face" id="p2Face" alt="ë©§ë´‰ì´" />
        </div>
      </div>

      <div class="controls">
        <button class="btn primary" id="resetBtn">ë‹¤ì‹œí•˜ê¸°</button>
        <button class="btn" id="toggleFirstBtn">ì„ ê³µ: ì—¬ë´‰ì´</button>
        <div class="chip" id="turnChip"><span class="dot"></span><span>ì—¬ë´‰ì´ ì°¨ë¡€</span></div>
      </div>
    </div>

    <div class="boardCard">
      <div class="boardWrap">
        <canvas id="board" width="650" height="650" aria-label="ì˜¤ëª©íŒ"></canvas>
      </div>
    </div>

    <div class="footer">
      <div class="msg" id="msg">ì›í•˜ëŠ” ê³³ì„ ëˆŒëŸ¬ ëŒì„ ë‘¬!</div>
      <div class="hint" id="hint">10Ã—10</div>
    </div>
  </div>

  <!-- âœ… ê²°ê³¼ íŒì—… -->
  <div class="modal-backdrop" id="modalBackdrop" role="dialog" aria-modal="true">
    <div class="modal">
      <h2 class="modalTitle" id="modalTitle">ìŠ¹ë¦¬!</h2>
      <div class="modalDesc" id="modalDesc">ë‹¤ì‹œ í•œ íŒ ê°€ì ğŸ˜</div>
      <div class="modalBtns">
        <button class="btn primary" id="modalRestartBtn">ë‹¤ì‹œí•˜ê¸°</button>
        <button class="btn" id="modalCloseBtn">ë‹«ê¸°</button>
      </div>
    </div>
  </div>

<script>
(() => {
  // =========================
  // ì„¤ì • (10x10)
  // =========================
  const SIZE = 10;
  const WIN = 5;

  const PLAYER = 1; // ì—¬ë´‰ì´
  const AI = 2;     // ë©§ë´‰ì´

  // ì´ë¯¸ì§€ (ì—†ì–´ë„ ê¸°ë³¸ ëŒë¡œ í‘œì‹œë¨)
  const IMG_P1 = "/img/omok_player.png";
  const IMG_P2 = "/img/omok_ai.png";

  // (í‘œì‹œ X) ë‚´ë¶€ ë‚œì´ë„ ìë™ ë³´ì •ìš©
  const TARGET_WIN_RATE = 0.30;
  const AI_MIN = 0.40;
  const AI_MAX = 0.95;
  const ADJUST_K = 0.22;
  const MAX_SOFT_CHOICE = 10;

  const LS_KEY = "yeobong_omok_flash_10x10_modal_v1";

  // =========================
  // DOM
  // =========================
  const canvas = document.getElementById("board");
  const ctx = canvas.getContext("2d");

  const resetBtn = document.getElementById("resetBtn");
  const toggleFirstBtn = document.getElementById("toggleFirstBtn");
  const turnChip = document.getElementById("turnChip");
  const msgEl = document.getElementById("msg");

  // modal
  const modalBackdrop = document.getElementById("modalBackdrop");
  const modalTitle = document.getElementById("modalTitle");
  const modalDesc = document.getElementById("modalDesc");
  const modalRestartBtn = document.getElementById("modalRestartBtn");
  const modalCloseBtn = document.getElementById("modalCloseBtn");

  const p1Face = document.getElementById("p1Face");
  const p2Face = document.getElementById("p2Face");
  p1Face.src = IMG_P1;
  p2Face.src = IMG_P2;

  function setMsg(t){ msgEl.textContent = t; }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function nameOf(p){ return p === PLAYER ? "ì—¬ë´‰ì´" : "ë©§ë´‰ì´"; }

  // =========================
  // ëª¨ë‹¬
  // =========================
  function openModal(title, desc){
    modalTitle.textContent = title;
    modalDesc.textContent = desc;
    modalBackdrop.classList.add("show");
  }
  function closeModal(){
    modalBackdrop.classList.remove("show");
  }

  // =========================
  // ìƒíƒœ
  // =========================
  let board = Array.from({ length: SIZE }, () => Array(SIZE).fill(0));
  let gameOver = false;

  let firstPlayer = PLAYER;
  let turn = PLAYER;
  let lastMove = null;

  // ë‚´ë¶€ ì „ì (í‘œì‹œ X)
  let results = [];
  let difficulty = 0.78;

  // =========================
  // ì €ì¥/ë¡œë“œ
  // =========================
  function loadState(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if(!raw) return;
      const s = JSON.parse(raw);
      if(Array.isArray(s.results)) results = s.results.filter(x => x==="W" || x==="L").slice(-10);
      if(typeof s.difficulty === "number") difficulty = clamp(s.difficulty, AI_MIN, AI_MAX);
      if(s.firstPlayer === PLAYER || s.firstPlayer === AI) firstPlayer = s.firstPlayer;
    }catch(e){}
  }
  function saveState(){
    localStorage.setItem(LS_KEY, JSON.stringify({ results, difficulty, firstPlayer }));
  }

  loadState();
  turn = firstPlayer;

  // =========================
  // ë Œë”ë§ ê³„ì‚°
  // =========================
  const W = canvas.width, H = canvas.height;
  const margin = 54;
  const gridSize = Math.min(W, H) - margin * 2;
  const cell = gridSize / (SIZE - 1);
  const r = cell * 0.42;

  // ì´ë¯¸ì§€
  const img1 = new Image(); img1.src = IMG_P1;
  const img2 = new Image(); img2.src = IMG_P2;

  // =========================
  // UI
  // =========================
  function setTurnUI(){
    const label = (turn === PLAYER) ? "ì—¬ë´‰ì´ ì°¨ë¡€" : "ë©§ë´‰ì´ ìƒê°ì¤‘â€¦";
    turnChip.innerHTML = `<span class="dot"></span><span>${label}</span>`;
    toggleFirstBtn.textContent = `ì„ ê³µ: ${nameOf(firstPlayer)}`;
  }

  // =========================
  // ì¢Œí‘œ
  // =========================
  function pointerToCell(clientX, clientY){
    const rect = canvas.getBoundingClientRect();
    const sx = canvas.width / rect.width;
    const sy = canvas.height / rect.height;
    const x = (clientX - rect.left) * sx;
    const y = (clientY - rect.top) * sy;

    const gx = (x - margin) / cell;
    const gy = (y - margin) / cell;

    return { x: clamp(Math.round(gx), 0, SIZE-1), y: clamp(Math.round(gy), 0, SIZE-1) };
  }

  // =========================
  // ìŠ¹ë¦¬ íŒì •
  // =========================
  function inRange(x,y){ return x>=0 && x<SIZE && y>=0 && y<SIZE; }
  function countDir(x,y,dx,dy,p){
    let c=0, nx=x+dx, ny=y+dy;
    while(inRange(nx,ny) && board[ny][nx]===p){ c++; nx+=dx; ny+=dy; }
    return c;
  }
  function isWin(x,y,p){
    const dirs = [[1,0],[0,1],[1,1],[1,-1]];
    for(const [dx,dy] of dirs){
      const line = 1 + countDir(x,y,dx,dy,p) + countDir(x,y,-dx,-dy,p);
      if(line >= WIN) return true;
    }
    return false;
  }
  function isDraw(){
    for(let y=0;y<SIZE;y++) for(let x=0;x<SIZE;x++) if(board[y][x]===0) return false;
    return true;
  }

  // =========================
  // ê·¸ë¦¬ê¸°
  // =========================
  function drawGrid(){
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = "rgba(255,255,255,.92)";
    ctx.fillRect(0,0,W,H);

    ctx.lineWidth = 1;
    ctx.strokeStyle = "rgba(0,0,0,.12)";
    for(let i=0;i<SIZE;i++){
      const px = margin + i*cell;
      const py = margin + i*cell;
      ctx.beginPath(); ctx.moveTo(px, margin); ctx.lineTo(px, margin+(SIZE-1)*cell); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(margin, py); ctx.lineTo(margin+(SIZE-1)*cell, py); ctx.stroke();
    }

    const c = Math.floor(SIZE/2);
    ctx.fillStyle = "rgba(0,0,0,.25)";
    ctx.beginPath();
    ctx.arc(margin + c*cell, margin + c*cell, 4, 0, Math.PI*2);
    ctx.fill();
  }

  function drawFallbackStone(cx, cy, rr, player){
    ctx.beginPath();
    ctx.arc(cx, cy, rr, 0, Math.PI*2);
    ctx.fillStyle = (player === PLAYER) ? "#111" : "#e5e7eb";
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(0,0,0,.25)";
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(cx - rr*0.22, cy - rr*0.22, rr*0.28, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255,255,255,.20)";
    ctx.fill();
  }

  function drawStone(x,y,p,isLast){
    const img = (p === PLAYER) ? img1 : img2;
    const cx = margin + x*cell;
    const cy = margin + y*cell;
    const canUseImage = img && img.complete && img.naturalWidth > 0;

    if(canUseImage){
      ctx.save();
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI*2);
      ctx.clip();
      ctx.drawImage(img, cx-r, cy-r, r*2, r*2);
      ctx.restore();
    }else{
      drawFallbackStone(cx, cy, r, p);
    }

    ctx.lineWidth = isLast ? 4 : 2;
    ctx.strokeStyle = isLast ? "rgba(0,0,0,.70)" : "rgba(0,0,0,.18)";
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI*2);
    ctx.stroke();
  }

  function draw(){
    drawGrid();
    for(let y=0;y<SIZE;y++){
      for(let x=0;x<SIZE;x++){
        const v = board[y][x];
        if(!v) continue;
        const isLast = lastMove && lastMove.x===x && lastMove.y===y;
        drawStone(x,y,v,isLast);
      }
    }
  }

  // =========================
  // AI(í‘œì‹œ X)
  // =========================
  function getWinRate(){
    const w = results.filter(r => r==="W").length;
    return results.length ? (w / results.length) : null;
  }
  function adjustDifficulty(){
    const wr = getWinRate();
    if(wr === null) return;
    const error = TARGET_WIN_RATE - wr;
    difficulty -= error * ADJUST_K;
    difficulty = clamp(difficulty, AI_MIN, AI_MAX);
  }
  function getMistakeRate(){
    const t = 1 - difficulty;
    return clamp(0.03 + t * 0.55, 0.03, 0.45);
  }

  function genCandidates(){
    const cand = [];
    let hasStone = false;
    const mark = Array.from({length: SIZE}, () => Array(SIZE).fill(false));

    for(let y=0;y<SIZE;y++){
      for(let x=0;x<SIZE;x++){
        if(board[y][x] !== 0){
          hasStone = true;
          for(let dy=-1; dy<=1; dy++){
            for(let dx=-1; dx<=1; dx++){
              const nx=x+dx, ny=y+dy;
              if(inRange(nx,ny) && board[ny][nx]===0) mark[ny][nx] = true;
            }
          }
        }
      }
    }
    if(!hasStone){
      const c = Math.floor(SIZE/2);
      return [
        {x:c,y:c},{x:c-1,y:c},{x:c,y:c-1},{x:c-1,y:c-1}
      ].filter(m => inRange(m.x,m.y));
    }
    for(let y=0;y<SIZE;y++) for(let x=0;x<SIZE;x++) if(mark[y][x]) cand.push({x,y});
    return cand;
  }

  function maxLineIfPlace(x,y,p){
    const dirs = [[1,0],[0,1],[1,1],[1,-1]];
    let best = 1;
    for(const [dx,dy] of dirs){
      const line = 1 + countDir(x,y,dx,dy,p) + countDir(x,y,-dx,-dy,p);
      if(line > best) best = line;
    }
    return best;
  }

  function scoreMove(x,y){
    const aiLine = maxLineIfPlace(x,y,AI);
    const plLine = maxLineIfPlace(x,y,PLAYER);

    const c = (SIZE-1)/2;
    const dist = Math.abs(x-c) + Math.abs(y-c);
    const centerScore = (SIZE*2 - dist);

    let score = 0;

    if(aiLine >= 5) score += 100000;
    else if(aiLine === 4) score += 2500;
    else if(aiLine === 3) score += 450;
    else if(aiLine === 2) score += 70;

    if(plLine >= 5) score += 90000;
    else if(plLine === 4) score += 2300;
    else if(plLine === 3) score += 420;
    else if(plLine === 2) score += 55;

    score += centerScore * 3;

    if(lastMove){
      const dx = Math.abs(x - lastMove.x);
      const dy = Math.abs(y - lastMove.y);
      const near = Math.max(0, 5 - (dx+dy));
      score += near * 8;
    }

    return score;
  }

  function findForcedMove(p){
    const cand = genCandidates();
    for(const m of cand){
      board[m.y][m.x] = p;
      const win = isWin(m.x, m.y, p);
      board[m.y][m.x] = 0;
      if(win) return m;
    }
    return null;
  }

  function rankMoves(){
    const cand = genCandidates();
    const ranked = cand.map(m => ({...m, score: scoreMove(m.x,m.y)}));
    ranked.sort((a,b) => b.score - a.score);
    return ranked;
  }

  function chooseAIMove(){
    const winMove = findForcedMove(AI);
    if(winMove) return winMove;

    const blockMove = findForcedMove(PLAYER);
    if(blockMove) return blockMove;

    const ranked = rankMoves();
    if(!ranked.length) return null;

    const doMistake = Math.random() < getMistakeRate();
    if(!doMistake) return { x: ranked[0].x, y: ranked[0].y };

    const widen = Math.floor((1 - difficulty) * MAX_SOFT_CHOICE);
    const maxIdx = clamp(1 + widen, 1, Math.min(MAX_SOFT_CHOICE, ranked.length)) - 1;
    const pick = Math.floor(Math.random() * (maxIdx + 1));
    return { x: ranked[pick].x, y: ranked[pick].y };
  }

  // =========================
  // ê²Œì„ ì§„í–‰
  // =========================
  function endGame(playerWon, type){
    gameOver = true;

    // ë‚´ë¶€ ì „ì /ë³´ì •
    if(type === "win") results.push("W");
    else if(type === "lose") results.push("L");
    results = results.slice(-10);
    adjustDifficulty();
    saveState();

    // âœ… íŒì—…
    if(type === "win"){
      openModal("ìŠ¹ë¦¬! ğŸ‰", "ë©§ë´‰ì´ ìš¸ê³  ê°â€¦ ë‹¤ì‹œ í•œ íŒ?");
    }else if(type === "lose"){
      openModal("íŒ¨ë°°! ğŸ˜µ", "ì•„ì‰½ë‹¤â€¦ ë‹¤ìŒ íŒì— ì´ê²¨ë³´ì!");
    }else{
      openModal("ë¬´ìŠ¹ë¶€! ğŸ¤", "íŒ½íŒ½í–ˆë‹¤â€¦ ë‹¤ì‹œ ê°€ì!");
    }
  }

  function place(x,y,who){
    if(gameOver) return false;
    if(board[y][x] !== 0) return false;

    board[y][x] = who;
    lastMove = { x, y, player: who };
    draw();

    if(isWin(x,y,who)){
      setMsg(`${nameOf(who)} ìŠ¹ë¦¬!`);
      if(who === PLAYER) endGame(true, "win");
      else endGame(false, "lose");
      return true;
    }
    if(isDraw()){
      setMsg("ë¬´ìŠ¹ë¶€!");
      endGame(false, "draw");
      return true;
    }
    return true;
  }

  function nextTurn(){
    turn = (turn === PLAYER) ? AI : PLAYER;
    setTurnUI();

    if(gameOver) return;

    if(turn === AI){
      setMsg("ë©§ë´‰ì´â€¦");
      setTimeout(() => {
        if(gameOver) return;
        const m = chooseAIMove();
        if(!m){
          setMsg("ë‹¤ì‹œí•˜ê¸°!");
          openModal("ì˜¤ë¥˜!", "AIê°€ ë‘˜ ê³³ì„ ëª» ì°¾ì•˜ì–´. ë‹¤ì‹œí•˜ê¸° ëˆŒëŸ¬ì¤˜!");
          gameOver = true;
          return;
        }
        place(m.x, m.y, AI);
        if(!gameOver){
          turn = PLAYER;
          setTurnUI();
          setMsg("ì—¬ë´‰ì´ ì°¨ë¡€!");
        }
      }, 150);
    } else {
      setMsg("ì—¬ë´‰ì´ ì°¨ë¡€!");
    }
  }

  function resetBoard(){
    closeModal();
    board = Array.from({ length: SIZE }, () => Array(SIZE).fill(0));
    gameOver = false;
    lastMove = null;
    turn = firstPlayer;
    setTurnUI();
    saveState();
    draw();

    if(turn === AI){
      setMsg("ë©§ë´‰ì´ ì„ ê³µ!");
      setTimeout(() => {
        const m = chooseAIMove();
        if(m){
          place(m.x, m.y, AI);
          if(!gameOver){
            turn = PLAYER;
            setTurnUI();
            setMsg("ì—¬ë´‰ì´ ì°¨ë¡€!");
          }
        }
      }, 150);
    }else{
      setMsg("ì›í•˜ëŠ” ê³³ì„ ëˆŒëŸ¬ ëŒì„ ë‘¬!");
    }
  }

  // =========================
  // ì…ë ¥
  // =========================
  canvas.addEventListener("pointerdown", (e) => {
    e.preventDefault();
    if(gameOver) return;          // âœ… ê²Œì„ ëë‚˜ë©´ íŒì—…ìœ¼ë¡œë§Œ
    if(turn !== PLAYER) return;

    const {x,y} = pointerToCell(e.clientX, e.clientY);
    const ok = place(x,y,PLAYER);
    if(!ok) return;
    if(!gameOver) nextTurn();
  }, { passive:false });

  canvas.addEventListener("contextmenu", (e) => e.preventDefault());

  resetBtn.addEventListener("click", () => resetBoard());
  toggleFirstBtn.addEventListener("click", () => {
    firstPlayer = (firstPlayer === PLAYER) ? AI : PLAYER;
    saveState();
    resetBoard();
  });

  // ëª¨ë‹¬ ë²„íŠ¼
  modalRestartBtn.addEventListener("click", () => resetBoard());
  modalCloseBtn.addEventListener("click", () => closeModal());

  // ë°°ê²½ í´ë¦­í•˜ë©´ ë‹«ê¸°(ì›ì¹˜ ì•Šìœ¼ë©´ ì´ ì´ë²¤íŠ¸ ì‚­ì œí•´ë„ ë¨)
  modalBackdrop.addEventListener("pointerdown", (e) => {
    if(e.target === modalBackdrop) closeModal();
  }, { passive:true });

  // ESCë¡œ ë‹«ê¸°(PC)
  window.addEventListener("keydown", (e) => {
    if(e.key === "Escape" && modalBackdrop.classList.contains("show")){
      closeModal();
    }
  });

  // =========================
  // ì‹œì‘
  // =========================
  setTurnUI();
  drawGrid();
  resetBoard();
})();
</script>
</body>
</html>

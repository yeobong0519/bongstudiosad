<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=1" />
  <title> ì˜¤ëª©ì™• ë©§ë´‰ì´ë¥¼ ì´ê²¨ë¼!  (AI)</title>
  <meta name="description" content="15x15 ì˜¤ëª© ë¯¸ë‹ˆê²Œì„ - ì—¬ë´‰ì´/ë©§ë´‰ì´ ì–¼êµ´ëŒ + ìŠ¹ë¥  30% ê·¼ì²˜ ìë™ ë³´ì • AI" />
  <style>
    :root { --bg:#f5f5f7; --card:#fff; --text:#222; --muted:#6b7280; }
    *{ box-sizing:border-box; }
    body{ margin:0; font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif; background:var(--bg); color:var(--text); }
    .app{ max-width:520px; margin:0 auto; min-height:100vh; padding:18px 14px 26px; display:flex; flex-direction:column; gap:12px; }
    .card{ background:var(--card); border:1px solid rgba(0,0,0,.08); border-radius:18px; box-shadow:0 6px 18px rgba(0,0,0,.06); padding:14px; }
    .top{ display:flex; align-items:flex-start; justify-content:space-between; gap:10px; }
    .title{ font-weight:900; font-size:18px; line-height:1.2; margin:0; }
    .sub{ margin:6px 0 0; font-size:12px; color:var(--muted); line-height:1.35; }
    .controls{ display:flex; flex-wrap:wrap; gap:8px; align-items:center; justify-content:flex-start; margin-top:10px; }
    .btn{
      appearance:none; border:1px solid rgba(0,0,0,.12);
      background:#fff; color:#111;
      padding:10px 12px; border-radius:12px;
      font-weight:800; font-size:13px;
      display:inline-flex; align-items:center; gap:8px;
      cursor:pointer;
    }
    .btn:active{ transform:translateY(1px); }
    .btn.primary{ background:#111; color:#fff; border-color:#111; }
    .pill{
      font-size:12px; font-weight:900;
      padding:8px 10px; border-radius:999px;
      background:rgba(0,0,0,.06);
      color:#111;
      display:inline-flex; align-items:center; gap:8px;
      border:1px solid rgba(0,0,0,.08);
    }
    .legend{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; color:var(--muted); font-size:12px; font-weight:800; }
    .face{ width:22px; height:22px; border-radius:999px; border:1px solid rgba(0,0,0,.12); background:#fff; object-fit:cover; }
    .boardWrap{ padding:12px; display:flex; align-items:center; justify-content:center; touch-action:manipulation; }
    canvas{
      width:min(92vw, 480px);
      height:min(92vw, 480px);
      border-radius:16px;
      background:#fff;
      border:1px solid rgba(0,0,0,.10);
      box-shadow:0 10px 20px rgba(0,0,0,.05);
    }
    .status{ display:flex; justify-content:space-between; align-items:center; gap:10px; margin-top:10px; color:#111; font-size:13px; font-weight:900; }
    .hint{ color:var(--muted); font-size:12px; font-weight:700; line-height:1.35; margin-top:6px; }
    .small{ font-size:12px; color:var(--muted); font-weight:800; }
    .line{ height:1px; background:rgba(0,0,0,.08); margin:10px 0; }
  </style>
</head>
<body>
  <div class="app">
    <div class="card">
      <div class="top">
        <div>
          <h1 class="title">ì—¬ë´‰ì´ vs ë©§ë´‰ì´ ì˜¤ëª© (15Ã—15 Â· AI)</h1>
          <p class="sub">
            ëª©í‘œ: ìµœê·¼ 10íŒ ê¸°ì¤€ â€œí”Œë ˆì´ì–´ ìŠ¹ë¥  ì•½ 30%â€ë¡œ ìˆ˜ë ´í•˜ë„ë¡ AIê°€ ìë™ ì¡°ì ˆë¼.
            (ì™„ì „ ê³ ì •ì´ ì•„ë‹ˆë¼, í‰ê· ì ìœ¼ë¡œ ê·¸ë ‡ê²Œ ë§ì¶°ì§€ëŠ” ë°©ì‹)
          </p>
        </div>
        <div class="legend" title="ëŒ ì´ë¯¸ì§€">
          <img class="face" id="p1Face" alt="ì—¬ë´‰ì´" />
          <span>ì—¬ë´‰ì´</span>
          <span class="small">vs</span>
          <img class="face" id="p2Face" alt="ë©§ë´‰ì´" />
          <span>ë©§ë´‰ì´(AI)</span>
        </div>
      </div>

      <div class="controls">
        <button class="btn primary" id="resetBtn">ë‹¤ì‹œí•˜ê¸°</button>
        <button class="btn" id="newMatchBtn">ì „ì  ì´ˆê¸°í™”</button>
        <button class="btn" id="toggleFirstBtn">ì„ ê³µ: ì—¬ë´‰ì´</button>
        <span class="pill" id="turnPill">í„´: ì—¬ë´‰ì´</span>
        <span class="pill" id="ratePill">ìµœê·¼10íŒ ìŠ¹ë¥ : -</span>
      </div>

      <div class="hint">
        ì´ë¯¸ì§€ íŒŒì¼ ê²½ë¡œ: <b>/img/yeobong.png</b>, <b>/img/metbong.png</b><br/>
        â€œ10íŒ ì¤‘ 3íŒâ€ ì²´ê°ì€ ì•„ë˜ ê°’ìœ¼ë¡œ ì¡°ì ˆë¼: <b>TARGET_WIN_RATE=0.30</b> / <b>AI_MIN~MAX</b>
      </div>
    </div>

    <div class="card boardWrap">
      <canvas id="board" width="600" height="600" aria-label="ì˜¤ëª©íŒ"></canvas>
    </div>

    <div class="card">
      <div class="status">
        <div id="msg">ì¤€ë¹„ ì™„ë£Œ.</div>
        <div class="small" id="coord">â€”</div>
      </div>
      <div class="line"></div>
      <div class="hint" id="debugHint">
        ì „ì : <span id="recordText">-</span><br/>
        í˜„ì¬ AI ê°•ë„(difficulty): <span id="diffText">-</span> / ì‹¤ìˆ˜í™•ë¥ : <span id="mistText">-</span>
      </div>
    </div>
  </div>

<script>
(() => {
  // =========================
  // ì„¤ì •
  // =========================
  const SIZE = 15;
  const WIN = 5;
  const PLAYER = 1;    // ì—¬ë´‰ì´
  const AI = 2;        // ë©§ë´‰ì´(AI)

  const CANVAS = document.getElementById("board");
  const ctx = CANVAS.getContext("2d");

  // ì´ë¯¸ì§€ ê²½ë¡œ
  const IMG_P1 = "/img/yeobong.png";
  const IMG_P2 = "/img/metbong.png";

  // "10íŒ ì¤‘ 3íŒ" ëª©í‘œ ìŠ¹ë¥ 
  const TARGET_WIN_RATE = 0.30;

  // AI ê°•ë„ ë²”ìœ„ (0~1) : ë‚®ì„ìˆ˜ë¡ ì‹¤ìˆ˜/ì•½í•¨
  const AI_MIN = 0.40;
  const AI_MAX = 0.95;

  // ìë™ ë³´ì • ê°•ë„(í¬ë©´ ë” ë¹ ë¥´ê²Œ 30%ë¡œ ìˆ˜ë ´)
  const ADJUST_K = 0.22;

  // AIê°€ ì‹¤ìˆ˜í•  ë•Œ: ìƒìœ„ í›„ë³´ ì¤‘ ëª‡ ë²ˆì§¸ê¹Œì§€ ëœë¤ ì„ íƒí• ì§€(ë‚œì´ë„ì— ë”°ë¼ ìë™)
  const MAX_SOFT_CHOICE = 10; // í›„ë³´ í’€ ìµœëŒ€ í¬ê¸°

  // localStorage í‚¤
  const LS_KEY = "yeobong_omok_v1";

  // =========================
  // UI
  // =========================
  const resetBtn = document.getElementById("resetBtn");
  const newMatchBtn = document.getElementById("newMatchBtn");
  const toggleFirstBtn = document.getElementById("toggleFirstBtn");
  const turnPill = document.getElementById("turnPill");
  const ratePill = document.getElementById("ratePill");
  const msgEl = document.getElementById("msg");
  const coordEl = document.getElementById("coord");
  const recordText = document.getElementById("recordText");
  const diffText = document.getElementById("diffText");
  const mistText = document.getElementById("mistText");

  const p1Face = document.getElementById("p1Face");
  const p2Face = document.getElementById("p2Face");
  p1Face.src = IMG_P1;
  p2Face.src = IMG_P2;

  function setMsg(t){ msgEl.textContent = t; }
  function playerName(p){ return p === PLAYER ? "ì—¬ë´‰ì´" : "ë©§ë´‰ì´"; }

  // =========================
  // ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸°
  // =========================
  function loadState(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if(!raw) return null;
      const s = JSON.parse(raw);
      if(!s || typeof s !== "object") return null;
      return s;
    }catch(e){
      return null;
    }
  }
  function saveState(){
    const s = {
      results,       // ìµœê·¼ ê²°ê³¼ë“¤: "W"(í”Œë ˆì´ì–´ ìŠ¹) / "L"(í”Œë ˆì´ì–´ íŒ¨)
      difficulty,    // í˜„ì¬ AI ê°•ë„
      firstPlayer    // ì„ ê³µ
    };
    localStorage.setItem(LS_KEY, JSON.stringify(s));
  }

  // =========================
  // ë‚´ë¶€ ìƒíƒœ
  // =========================
  let board = Array.from({ length: SIZE }, () => Array(SIZE).fill(0));
  let gameOver = false;

  let firstPlayer = PLAYER; // ê¸°ë³¸ ì„ ê³µ: í”Œë ˆì´ì–´
  let turn = firstPlayer;
  let lastMove = null;

  // ìµœê·¼ ì „ì (í”Œë ˆì´ì–´ ê¸°ì¤€) - ìµœê·¼ 10íŒë§Œ ìš´ì˜
  let results = []; // ["W","L",...]
  let difficulty = 0.78; // ì‹œì‘ê°’(ê½¤ ê°•í•¨)

  // ë¶ˆëŸ¬ì˜¤ê¸°
  const saved = loadState();
  if(saved){
    if(Array.isArray(saved.results)) results = saved.results.filter(x => x === "W" || x === "L").slice(-10);
    if(typeof saved.difficulty === "number") difficulty = clamp(saved.difficulty, AI_MIN, AI_MAX);
    if(saved.firstPlayer === PLAYER || saved.firstPlayer === AI) firstPlayer = saved.firstPlayer;
  }
  turn = firstPlayer;

  // =========================
  // ë Œë”ë§ ê³„ì‚°
  // =========================
  const W = CANVAS.width;
  const H = CANVAS.height;
  const margin = 36;
  const gridSize = Math.min(W, H) - margin * 2;
  const cell = gridSize / (SIZE - 1);
  const r = cell * 0.42;

  // ì´ë¯¸ì§€ ë¡œë“œ
  const img1 = new Image();
  const img2 = new Image();
  img1.src = IMG_P1;
  img2.src = IMG_P2;

  let imagesReady = 0;
  img1.onload = () => { imagesReady++; if(imagesReady===2) draw(); };
  img2.onload = () => { imagesReady++; if(imagesReady===2) draw(); };

  // =========================
  // ìœ í‹¸
  // =========================
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function inRange(x,y){ return x>=0 && x<SIZE && y>=0 && y<SIZE; }
  function setTurnUI(){
    turnPill.textContent = `í„´: ${playerName(turn)}${turn===AI ? "(AI)" : ""}`;
    toggleFirstBtn.textContent = `ì„ ê³µ: ${playerName(firstPlayer)}`;
  }

  function getWinRate(){
    const w = results.filter(r => r === "W").length;
    return results.length ? (w / results.length) : null;
  }

  function updateRateUI(){
    const wr = getWinRate();
    if(wr === null){
      ratePill.textContent = "ìµœê·¼10íŒ ìŠ¹ë¥ : -";
      recordText.textContent = "-";
    }else{
      const pct = Math.round(wr*100);
      ratePill.textContent = `ìµœê·¼10íŒ ìŠ¹ë¥ : ${pct}% (${results.filter(r=>"W"===r).length}/${results.length})`;
      recordText.textContent = results.join(" ");
    }
  }

  // ìŠ¹ë¥  ë³´ì •: í”Œë ˆì´ì–´ ìŠ¹ë¥ ì´ ëª©í‘œë³´ë‹¤ ë‚®ìœ¼ë©´ AI ì•½í™”(ë‚œì´ë„â†“), ë†’ìœ¼ë©´ ê°•í™”(ë‚œì´ë„â†‘)
  function adjustDifficulty(){
    const wr = getWinRate();
    if(wr === null) return;

    const error = TARGET_WIN_RATE - wr;  // +ë©´ í”Œë ˆì´ì–´ ìŠ¹ë¥ ì´ ë‚®ìŒ => AI ì•½í™”ê°€ í•„ìš”
    difficulty -= error * ADJUST_K;      // difficulty ë‚®ì•„ì§€ë©´ ì‹¤ìˆ˜â†‘
    difficulty = clamp(difficulty, AI_MIN, AI_MAX);
  }

  // í˜„ì¬ ì‹¤ìˆ˜ í™•ë¥ (ë‚œì´ë„ì— ë”°ë¥¸)
  function getMistakeRate(){
    // difficulty 1.0ì´ë©´ ê±°ì˜ ì‹¤ìˆ˜ ì•ˆ í•¨, 0.4ë©´ ì‹¤ìˆ˜ ê½¤ í•¨
    // ê°’ì€ ì²´ê°ìš©: í•„ìš”í•˜ë©´ ì—¬ê¸° ìˆ«ìë§Œ ì¡°ì ˆí•˜ë©´ ë¨.
    const t = 1 - difficulty;            // 0~0.6
    return clamp(0.03 + t * 0.55, 0.03, 0.45); // 3%~45%
  }

  function updateDebugUI(){
    diffText.textContent = difficulty.toFixed(2);
    mistText.textContent = Math.round(getMistakeRate()*100) + "%";
  }

  function pointerToCell(clientX, clientY){
    const rect = CANVAS.getBoundingClientRect();
    const scaleX = CANVAS.width / rect.width;
    const scaleY = CANVAS.height / rect.height;
    const x = (clientX - rect.left) * scaleX;
    const y = (clientY - rect.top) * scaleY;

    const gx = (x - margin) / cell;
    const gy = (y - margin) / cell;
    const ix = Math.round(gx);
    const iy = Math.round(gy);

    return { x: clamp(ix,0,SIZE-1), y: clamp(iy,0,SIZE-1) };
  }

  // =========================
  // ìŠ¹ë¦¬ íŒì •
  // =========================
  function countDir(x,y,dx,dy,p){
    let c=0, nx=x+dx, ny=y+dy;
    while(inRange(nx,ny) && board[ny][nx]===p){ c++; nx+=dx; ny+=dy; }
    return c;
  }
  function isWin(x,y,p){
    const dirs = [[1,0],[0,1],[1,1],[1,-1]];
    for(const [dx,dy] of dirs){
      const line = 1 + countDir(x,y,dx,dy,p) + countDir(x,y,-dx,-dy,p);
      if(line >= WIN) return true;
    }
    return false;
  }
  function isDraw(){
    for(let y=0;y<SIZE;y++) for(let x=0;x<SIZE;x++) if(board[y][x]===0) return false;
    return true;
  }

  // =========================
  // ê·¸ë¦¬ê¸°
  // =========================
  function drawGrid(){
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle="#fff";
    ctx.fillRect(0,0,W,H);

    ctx.lineWidth=1;
    ctx.strokeStyle="rgba(0,0,0,0.18)";
    for(let i=0;i<SIZE;i++){
      const px = margin + i*cell;
      const py = margin + i*cell;

      ctx.beginPath(); ctx.moveTo(px, margin); ctx.lineTo(px, margin+(SIZE-1)*cell); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(margin, py); ctx.lineTo(margin+(SIZE-1)*cell, py); ctx.stroke();
    }

    const stars = [[3,3],[11,3],[3,11],[11,11],[7,7]];
    ctx.fillStyle="rgba(0,0,0,0.25)";
    for(const [sx,sy] of stars){
      const x = margin + sx*cell;
      const y = margin + sy*cell;
      ctx.beginPath(); ctx.arc(x,y,4,0,Math.PI*2); ctx.fill();
    }
  }

  function drawStone(x,y,p,isLast){
    const img = (p===PLAYER) ? img1 : img2;
    const cx = margin + x*cell;
    const cy = margin + y*cell;

    ctx.save();
    ctx.beginPath();
    ctx.arc(cx,cy,r,0,Math.PI*2);
    ctx.clip();
    ctx.drawImage(img, cx-r, cy-r, r*2, r*2);
    ctx.restore();

    ctx.lineWidth = isLast ? 4 : 2;
    ctx.strokeStyle = isLast ? "rgba(0,0,0,0.75)" : "rgba(0,0,0,0.25)";
    ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.stroke();
  }

  function draw(){
    drawGrid();
    for(let y=0;y<SIZE;y++){
      for(let x=0;x<SIZE;x++){
        const v = board[y][x];
        if(!v) continue;
        const isLast = lastMove && lastMove.x===x && lastMove.y===y;
        drawStone(x,y,v,isLast);
      }
    }
  }

  // =========================
  // AI ë¡œì§
  // =========================

  // í›„ë³´ ìƒì„±: ì´ë¯¸ ë†“ì¸ ëŒ ê·¼ì²˜ë§Œ íƒìƒ‰(ì†ë„/ìì—°ìŠ¤ëŸ¬ì›€)
  function genCandidates(){
    const cand = [];
    let hasStone = false;

    // ì´ë¯¸ ëŒì´ ìˆìœ¼ë©´ ê·¸ ì£¼ë³€ 2ì¹¸ ì´ë‚´ë§Œ
    const mark = Array.from({length: SIZE}, () => Array(SIZE).fill(false));
    for(let y=0;y<SIZE;y++){
      for(let x=0;x<SIZE;x++){
        if(board[y][x]!==0){
          hasStone = true;
          for(let dy=-2; dy<=2; dy++){
            for(let dx=-2; dx<=2; dx++){
              const nx=x+dx, ny=y+dy;
              if(inRange(nx,ny) && board[ny][nx]===0){
                mark[ny][nx] = true;
              }
            }
          }
        }
      }
    }

    if(!hasStone){
      // ì²« ìˆ˜ëŠ” ì¤‘ì•™ ê·¼ì²˜ë§Œ
      const c = Math.floor(SIZE/2);
      for(let y=c-1;y<=c+1;y++) for(let x=c-1;x<=c+1;x++){
        if(inRange(x,y)) cand.push({x,y});
      }
      return cand;
    }

    for(let y=0;y<SIZE;y++){
      for(let x=0;x<SIZE;x++){
        if(mark[y][x]) cand.push({x,y});
      }
    }
    return cand;
  }

  // íŠ¹ì • ì¢Œí‘œì— pë¥¼ ë‘ì—ˆì„ ë•Œ "ì—°ì†ìˆ˜ ìµœëŒ€" ê³„ì‚°
  function maxLineIfPlace(x,y,p){
    const dirs = [[1,0],[0,1],[1,1],[1,-1]];
    let best = 1;
    for(const [dx,dy] of dirs){
      const line = 1 + countDir(x,y,dx,dy,p) + countDir(x,y,-dx,-dy,p);
      if(line > best) best = line;
    }
    return best;
  }

  // ê°„ë‹¨ í‰ê°€ í•¨ìˆ˜ (í° ì ìˆ˜ì¼ìˆ˜ë¡ ì¢‹ìŒ)
  function scoreMove(x,y){
    // 1) ì¦‰ì‹œ ìŠ¹ë¦¬ / ì¦‰ì‹œ ë°©ì–´ëŠ” ë³„ë„ë¡œ ì²˜ë¦¬í•˜ì§€ë§Œ ì ìˆ˜ì—ë„ ë°˜ì˜
    const aiLine = maxLineIfPlace(x,y,AI);
    const plLine = maxLineIfPlace(x,y,PLAYER);

    // 2) ì¤‘ì•™ ì„ í˜¸
    const c = (SIZE-1)/2;
    const dist = Math.abs(x-c) + Math.abs(y-c);
    const centerScore = (SIZE*2 - dist); // í´ìˆ˜ë¡ ì¢‹ìŒ

    // 3) ê¸°ë³¸ ê°€ì¤‘ì¹˜
    let score = 0;

    // AI ê³µê²©ì„±
    if(aiLine >= 5) score += 100000;
    else if(aiLine === 4) score += 2500;
    else if(aiLine === 3) score += 450;
    else if(aiLine === 2) score += 70;

    // ìƒëŒ€ ê²¬ì œ
    if(plLine >= 5) score += 90000;
    else if(plLine === 4) score += 2300;
    else if(plLine === 3) score += 420;
    else if(plLine === 2) score += 55;

    // ì¤‘ì•™ ë³´ì •
    score += centerScore * 2;

    // ë§ˆì§€ë§‰ ìˆ˜ ì£¼ë³€ ê°€ì‚°(ìì—°ìŠ¤ëŸ½ê²Œ ë¶™ëŠ” ëŠë‚Œ)
    if(lastMove){
      const dx = Math.abs(x - lastMove.x);
      const dy = Math.abs(y - lastMove.y);
      const near = Math.max(0, 6 - (dx+dy));
      score += near * 6;
    }

    return score;
  }

  // "ì¦‰ì‹œ ì´ê¹€" ë˜ëŠ” "ì¦‰ì‹œ ë§‰ìŒ" ì°¾ê¸°
  function findForcedMove(p){
    const cand = genCandidates();
    for(const m of cand){
      // ì„ì‹œë¡œ ë‘ê³  ìŠ¹ë¦¬ ì—¬ë¶€ í™•ì¸
      board[m.y][m.x] = p;
      const win = isWin(m.x, m.y, p);
      board[m.y][m.x] = 0;
      if(win) return m;
    }
    return null;
  }

  function rankMoves(){
    const cand = genCandidates();
    const ranked = cand.map(m => ({...m, score: scoreMove(m.x,m.y)}));
    ranked.sort((a,b) => b.score - a.score);
    return ranked;
  }

  function chooseAIMove(){
    // 1) ì´ê¸¸ ìˆ˜ ìˆìœ¼ë©´ ì¦‰ì‹œ ì´ê¹€
    const winMove = findForcedMove(AI);
    if(winMove) return winMove;

    // 2) ë§‰ì•„ì•¼ í•˜ë©´ ì¦‰ì‹œ ë§‰ìŒ
    const blockMove = findForcedMove(PLAYER);
    if(blockMove) return blockMove;

    // 3) ë­í‚¹ ê¸°ë°˜ ì„ íƒ + ì‹¤ìˆ˜(soft choice)
    const ranked = rankMoves();
    if(!ranked.length) return null;

    // ì‹¤ìˆ˜ í™•ë¥ 
    const mistakeRate = getMistakeRate();
    const doMistake = Math.random() < mistakeRate;

    if(!doMistake){
      return { x: ranked[0].x, y: ranked[0].y };
    }

    // "ì‹¤ìˆ˜"ë„ ì•„ë¬´ ë°ë‚˜ê°€ ì•„ë‹ˆë¼: ìƒìœ„ Nê°œ ì¤‘ ëœë¤(ë‚œì´ë„ì— ë”°ë¼ N ì¡°ì ˆ)
    // difficulty ë‚®ì„ìˆ˜ë¡ ë” ë„“ê²Œ(ë” ì´ìƒí•œ ìˆ˜) ë½‘ì„ ìˆ˜ ìˆìŒ
    const widen = Math.floor((1 - difficulty) * MAX_SOFT_CHOICE); // 0~6 ì •ë„
    const maxIdx = clamp(1 + widen, 1, Math.min(MAX_SOFT_CHOICE, ranked.length) ) - 1;
    const pick = Math.floor(Math.random() * (maxIdx + 1));
    return { x: ranked[pick].x, y: ranked[pick].y };
  }

  // =========================
  // ê²Œì„ ì§„í–‰
  // =========================
  function endGame(playerWon){
    gameOver = true;

    // ì „ì  ê¸°ë¡(í”Œë ˆì´ì–´ ê¸°ì¤€)
    results.push(playerWon ? "W" : "L");
    results = results.slice(-10);

    // ë‚œì´ë„ ë³´ì •
    adjustDifficulty();

    // ì €ì¥/í‘œì‹œ
    updateRateUI();
    updateDebugUI();
    saveState();
  }

  function place(x,y,who){
    if(gameOver) return false;
    if(board[y][x] !== 0) return false;

    board[y][x] = who;
    lastMove = { x, y, player: who };
    draw();

    if(isWin(x,y,who)){
      setTurnUI();
      setMsg(`ìŠ¹ë¦¬! ${playerName(who)}ê°€ 5ëª©ì„ ë§Œë“¤ì—ˆì–´ ğŸ‰`);
      endGame(who === PLAYER);
      return true;
    }

    if(isDraw()){
      gameOver = true;
      setMsg("ë¬´ìŠ¹ë¶€! íŒì´ ê½‰ ì°¼ì–´ ğŸ˜µâ€ğŸ’«");
      // ë¬´ìŠ¹ë¶€ëŠ” ì „ì ì— ë°˜ì˜ ì•ˆ í•˜ê³  ì‹¶ìœ¼ë©´ ì—¬ê¸°ì„œ returnë§Œ
      updateRateUI();
      updateDebugUI();
      saveState();
      return true;
    }

    return true;
  }

  function nextTurn(){
    turn = (turn === PLAYER) ? AI : PLAYER;
    setTurnUI();

    if(gameOver) return;

    if(turn === AI){
      setMsg("ë©§ë´‰ì´(AI)ê°€ ìƒê°ì¤‘â€¦");
      // ì‚´ì§ í…œí¬(ì‚¬ëŒì²˜ëŸ¼)
      setTimeout(() => {
        if(gameOver) return;
        const m = chooseAIMove();
        if(!m){
          setMsg("AIê°€ ë‘˜ ê³³ì„ ëª» ì°¾ì•˜ì–´(ì´ìƒí•¨). ë‹¤ì‹œí•˜ê¸° ëˆŒëŸ¬ì¤˜!");
          return;
        }
        place(m.x, m.y, AI);
        if(!gameOver){
          turn = PLAYER;
          setTurnUI();
          setMsg("ì—¬ë´‰ì´ ì°¨ë¡€!");
        }
      }, 180);
    } else {
      setMsg("ì—¬ë´‰ì´ ì°¨ë¡€!");
    }
  }

  function resetBoard(){
    board = Array.from({ length: SIZE }, () => Array(SIZE).fill(0));
    gameOver = false;
    lastMove = null;
    turn = firstPlayer;
    setTurnUI();
    updateRateUI();
    updateDebugUI();
    saveState();
    draw();
    if(turn === AI){
      setMsg("ë©§ë´‰ì´(AI) ì„ ê³µ!");
      // AI ì„ ê³µ
      setTimeout(() => {
        const m = chooseAIMove();
        if(m) {
          place(m.x, m.y, AI);
          if(!gameOver){
            turn = PLAYER;
            setTurnUI();
            setMsg("ì—¬ë´‰ì´ ì°¨ë¡€!");
          }
        }
      }, 180);
    } else {
      setMsg("ìƒˆ ê²Œì„ ì‹œì‘! ì›í•˜ëŠ” ê³³ì„ ëˆŒëŸ¬ì„œ ëŒì„ ë‘¬.");
    }
  }

  // =========================
  // ì…ë ¥ ì²˜ë¦¬
  // =========================
  function onBoardClick(e){
    if(gameOver) return;
    if(turn !== PLAYER) return; // í”Œë ˆì´ì–´ í„´ì—ë§Œ ì…ë ¥
    const pt = (e.touches && e.touches[0]) ? e.touches[0] : e;
    const {x,y} = pointerToCell(pt.clientX, pt.clientY);
    coordEl.textContent = `ì¢Œí‘œ: (${x+1}, ${y+1})`;

    const ok = place(x,y,PLAYER);
    if(ok && !gameOver){
      nextTurn(); // AI í„´ìœ¼ë¡œ ë„˜ê¹€
    }
  }

  CANVAS.addEventListener("click", onBoardClick, { passive:true });
  CANVAS.addEventListener("touchstart", (e) => {
    e.preventDefault();
    onBoardClick(e);
  }, { passive:false });

  resetBtn.addEventListener("click", () => resetBoard());

  toggleFirstBtn.addEventListener("click", () => {
    firstPlayer = (firstPlayer === PLAYER) ? AI : PLAYER;
    turn = firstPlayer;
    saveState();
    resetBoard();
  });

  newMatchBtn.addEventListener("click", () => {
    results = [];
    difficulty = 0.78; // ì´ˆê¸°í™”
    saveState();
    updateRateUI();
    updateDebugUI();
    setMsg("ì „ì  ì´ˆê¸°í™” ì™„ë£Œ! ë‹¤ì‹œí•˜ê¸° ëˆ„ë¥´ë©´ ìƒˆë¡œ ì‹œì‘í•´.");
  });

  // =========================
  // ì´ˆê¸°í™”
  // =========================
  setTurnUI();
  drawGrid();
  updateRateUI();
  updateDebugUI();

  // ì´ë¯¸ì§€ ìºì‹œ ëŒ€ë¹„
  const checkReady = setInterval(() => {
    if(img1.complete && img2.complete){
      clearInterval(checkReady);
      resetBoard();
    }
  }, 50);

  // ====== drawGrid í•¨ìˆ˜(ì´ˆê¸° ê²©ì í‘œì‹œìš©) ======
  function drawGrid(){
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle="#fff";
    ctx.fillRect(0,0,W,H);

    ctx.lineWidth=1;
    ctx.strokeStyle="rgba(0,0,0,0.18)";
    for(let i=0;i<SIZE;i++){
      const px = margin + i*cell;
      const py = margin + i*cell;
      ctx.beginPath(); ctx.moveTo(px, margin); ctx.lineTo(px, margin+(SIZE-1)*cell); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(margin, py); ctx.lineTo(margin+(SIZE-1)*cell, py); ctx.stroke();
    }
    const stars = [[3,3],[11,3],[3,11],[11,11],[7,7]];
    ctx.fillStyle="rgba(0,0,0,0.25)";
    for(const [sx,sy] of stars){
      const x = margin + sx*cell;
      const y = margin + sy*cell;
      ctx.beginPath(); ctx.arc(x,y,4,0,Math.PI*2); ctx.fill();
    }
  }
})();
</script>
</body>
</html>

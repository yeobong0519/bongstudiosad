<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>오목왕! 멧봉이를 이겨라!</title>
  <style>
    :root{
      --bg:#0b0f19;
      --card:rgba(255,255,255,.08);
      --line:rgba(255,255,255,.14);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.62);
      --btn:rgba(255,255,255,.10);
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      background: radial-gradient(1200px 700px at 50% -100px, rgba(255,255,255,.14), transparent 65%),
                  radial-gradient(1000px 600px at 10% 110%, rgba(255,255,255,.10), transparent 60%),
                  var(--bg);
      color:var(--text);
    }
    .app{
      max-width:560px;
      margin:0 auto;
      padding:16px 14px 22px;
      display:flex;
      flex-direction:column;
      gap:12px;
      min-height:100vh;
    }
    .header{
      padding:14px 14px;
      border:1px solid var(--line);
      background:linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      border-radius:18px;
      box-shadow:0 10px 30px rgba(0,0,0,.25);
    }
    .topRow{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .title{ margin:0; font-size:18px; font-weight:900; letter-spacing:-.2px; }
    .sub{ margin:6px 0 0; font-size:12px; color:var(--muted); line-height:1.35; }
    .faces{ display:flex; align-items:center; gap:8px; flex-shrink:0; }
    .face{
      width:28px; height:28px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.25);
      background:rgba(255,255,255,.10);
      object-fit:cover;
    }
    .vs{ font-size:11px; color:var(--muted); font-weight:900; }

    .controls{ margin-top:12px; display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .btn{
      appearance:none;
      border:1px solid rgba(255,255,255,.18);
      background:var(--btn);
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      font-weight:900;
      font-size:13px;
      cursor:pointer;
      user-select:none;
      backdrop-filter: blur(8px);
    }
    .btn:active{ transform:translateY(1px); }
    .btn.primary{
      background:rgba(255,255,255,.92);
      color:#0b0f19;
      border-color:rgba(255,255,255,.92);
    }
    .chip{
      margin-left:auto;
      padding:9px 12px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.18);
      background:var(--card);
      font-size:12px;
      font-weight:900;
      color:var(--text);
      display:flex;
      align-items:center;
      gap:8px;
    }
    .dot{
      width:8px;height:8px;border-radius:999px;
      background:rgba(255,255,255,.85);
      box-shadow:0 0 0 4px rgba(255,255,255,.10);
    }

    .boardCard{
      border:1px solid var(--line);
      background:linear-gradient(180deg, rgba(255,255,255,.09), rgba(255,255,255,.05));
      border-radius:20px;
      padding:14px;
      box-shadow:0 12px 34px rgba(0,0,0,.28);
    }
    .boardWrap{ display:flex; align-items:center; justify-content:center; padding:6px; }
    canvas{
      width:min(94vw, 520px);
      height:min(94vw, 520px);
      border-radius:18px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.92);
      box-shadow:0 14px 28px rgba(0,0,0,.28);
      touch-action:none;
    }

    .footer{
      border:1px solid var(--line);
      background:var(--card);
      border-radius:18px;
      padding:12px 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .msg{ font-weight:900; font-size:13px; letter-spacing:-.1px; }
    .hint{ font-size:12px; color:var(--muted); font-weight:800; white-space:nowrap; }
  </style>
</head>
<body>
  <div class="app">
    <div class="header">
      <div class="topRow">
        <div>
          <h1 class="title">여봉이 오목</h1>
          <div class="sub">한 번 눌러서 돌 놓기 · 5목 먼저 만들면 승리</div>
        </div>
        <div class="faces" title="돌 스킨">
          <img class="face" id="p1Face" alt="여봉이" />
          <span class="vs">VS</span>
          <img class="face" id="p2Face" alt="멧봉이" />
        </div>
      </div>

      <div class="controls">
        <button class="btn primary" id="resetBtn">다시하기</button>
        <button class="btn" id="toggleFirstBtn">선공: 여봉이</button>
        <div class="chip" id="turnChip"><span class="dot"></span><span>여봉이 차례</span></div>
      </div>
    </div>

    <div class="boardCard">
      <div class="boardWrap">
        <canvas id="board" width="650" height="650" aria-label="오목판"></canvas>
      </div>
    </div>

    <div class="footer">
      <div class="msg" id="msg">원하는 곳을 눌러 돌을 둬!</div>
      <div class="hint" id="hint">10×10</div>
    </div>
  </div>

<script>
(() => {
  // =========================
  // 설정 (✅ 10x10)
  // =========================
  const SIZE = 10;        // ✅ 변경
  const WIN = 5;          // 5목 유지

  const PLAYER = 1; // 여봉이
  const AI = 2;     // 멧봉이

  const IMG_P1 = "/img/yeobong.png";
  const IMG_P2 = "/img/metbong.png";

  // (표시 X) 내부 난이도 자동 보정용
  const TARGET_WIN_RATE = 0.30;
  const AI_MIN = 0.40;
  const AI_MAX = 0.95;
  const ADJUST_K = 0.22;
  const MAX_SOFT_CHOICE = 10;

  const LS_KEY = "yeobong_omok_flash_10x10_v1";

  // =========================
  // DOM
  // =========================
  const canvas = document.getElementById("board");
  const ctx = canvas.getContext("2d");

  const resetBtn = document.getElementById("resetBtn");
  const toggleFirstBtn = document.getElementById("toggleFirstBtn");
  const turnChip = document.getElementById("turnChip");
  const msgEl = document.getElementById("msg");

  const p1Face = document.getElementById("p1Face");
  const p2Face = document.getElementById("p2Face");
  p1Face.src = IMG_P1;
  p2Face.src = IMG_P2;

  function setMsg(t){ msgEl.textContent = t; }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function nameOf(p){ return p === PLAYER ? "여봉이" : "멧봉이"; }

  // =========================
  // 상태
  // =========================
  let board = Array.from({ length: SIZE }, () => Array(SIZE).fill(0));
  let gameOver = false;

  let firstPlayer = PLAYER;
  let turn = PLAYER;
  let lastMove = null;

  // 내부 전적(표시 X)
  let results = [];
  let difficulty = 0.78;

  // =========================
  // 저장/로드
  // =========================
  function loadState(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if(!raw) return;
      const s = JSON.parse(raw);
      if(Array.isArray(s.results)) results = s.results.filter(x => x==="W" || x==="L").slice(-10);
      if(typeof s.difficulty === "number") difficulty = clamp(s.difficulty, AI_MIN, AI_MAX);
      if(s.firstPlayer === PLAYER || s.firstPlayer === AI) firstPlayer = s.firstPlayer;
    }catch(e){}
  }
  function saveState(){
    localStorage.setItem(LS_KEY, JSON.stringify({ results, difficulty, firstPlayer }));
  }

  loadState();
  turn = firstPlayer;

  // =========================
  // 렌더링 계산
  // =========================
  const W = canvas.width, H = canvas.height;
  const margin = 54; // ✅ 10x10이라 여백 살짝 늘려서 보기 좋게
  const gridSize = Math.min(W, H) - margin * 2;
  const cell = gridSize / (SIZE - 1);
  const r = cell * 0.42;

  // =========================
  // 이미지
  // =========================
  const img1 = new Image(); img1.src = IMG_P1;
  const img2 = new Image(); img2.src = IMG_P2;

  // =========================
  // UI
  // =========================
  function setTurnUI(){
    const label = (turn === PLAYER) ? "여봉이 차례" : "멧봉이 생각중…";
    turnChip.innerHTML = `<span class="dot"></span><span>${label}</span>`;
    toggleFirstBtn.textContent = `선공: ${nameOf(firstPlayer)}`;
  }

  // =========================
  // 좌표
  // =========================
  function pointerToCell(clientX, clientY){
    const rect = canvas.getBoundingClientRect();
    const sx = canvas.width / rect.width;
    const sy = canvas.height / rect.height;
    const x = (clientX - rect.left) * sx;
    const y = (clientY - rect.top) * sy;

    const gx = (x - margin) / cell;
    const gy = (y - margin) / cell;

    return { x: clamp(Math.round(gx), 0, SIZE-1), y: clamp(Math.round(gy), 0, SIZE-1) };
  }

  // =========================
  // 승리 판정
  // =========================
  function inRange(x,y){ return x>=0 && x<SIZE && y>=0 && y<SIZE; }
  function countDir(x,y,dx,dy,p){
    let c=0, nx=x+dx, ny=y+dy;
    while(inRange(nx,ny) && board[ny][nx]===p){ c++; nx+=dx; ny+=dy; }
    return c;
  }
  function isWin(x,y,p){
    const dirs = [[1,0],[0,1],[1,1],[1,-1]];
    for(const [dx,dy] of dirs){
      const line = 1 + countDir(x,y,dx,dy,p) + countDir(x,y,-dx,-dy,p);
      if(line >= WIN) return true;
    }
    return false;
  }
  function isDraw(){
    for(let y=0;y<SIZE;y++) for(let x=0;x<SIZE;x++) if(board[y][x]===0) return false;
    return true;
  }

  // =========================
  // 그리기
  // =========================
  function drawGrid(){
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = "rgba(255,255,255,.92)";
    ctx.fillRect(0,0,W,H);

    ctx.lineWidth = 1;
    ctx.strokeStyle = "rgba(0,0,0,.12)";
    for(let i=0;i<SIZE;i++){
      const px = margin + i*cell;
      const py = margin + i*cell;
      ctx.beginPath(); ctx.moveTo(px, margin); ctx.lineTo(px, margin+(SIZE-1)*cell); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(margin, py); ctx.lineTo(margin+(SIZE-1)*cell, py); ctx.stroke();
    }

    // ✅ 10x10 화점: 중앙만(플래시 느낌)
    const c = Math.floor(SIZE/2);
    ctx.fillStyle = "rgba(0,0,0,.25)";
    ctx.beginPath();
    ctx.arc(margin + c*cell, margin + c*cell, 4, 0, Math.PI*2);
    ctx.fill();
  }

  function drawFallbackStone(cx, cy, rr, player){
    ctx.beginPath();
    ctx.arc(cx, cy, rr, 0, Math.PI*2);
    ctx.fillStyle = (player === PLAYER) ? "#111" : "#e5e7eb";
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(0,0,0,.25)";
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(cx - rr*0.22, cy - rr*0.22, rr*0.28, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255,255,255,.20)";
    ctx.fill();
  }

  function drawStone(x,y,p,isLast){
    const img = (p === PLAYER) ? img1 : img2;
    const cx = margin + x*cell;
    const cy = margin + y*cell;
    const canUseImage = img && img.complete && img.naturalWidth > 0;

    if(canUseImage){
      ctx.save();
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI*2);
      ctx.clip();
      ctx.drawImage(img, cx-r, cy-r, r*2, r*2);
      ctx.restore();
    }else{
      drawFallbackStone(cx, cy, r, p);
    }

    ctx.lineWidth = isLast ? 4 : 2;
    ctx.strokeStyle = isLast ? "rgba(0,0,0,.70)" : "rgba(0,0,0,.18)";
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI*2);
    ctx.stroke();
  }

  function draw(){
    drawGrid();
    for(let y=0;y<SIZE;y++){
      for(let x=0;x<SIZE;x++){
        const v = board[y][x];
        if(!v) continue;
        const isLast = lastMove && lastMove.x===x && lastMove.y===y;
        drawStone(x,y,v,isLast);
      }
    }
  }

  // =========================
  // AI(표시 X)
  // =========================
  function getWinRate(){
    const w = results.filter(r => r==="W").length;
    return results.length ? (w / results.length) : null;
  }
  function adjustDifficulty(){
    const wr = getWinRate();
    if(wr === null) return;
    const error = TARGET_WIN_RATE - wr;
    difficulty -= error * ADJUST_K;
    difficulty = clamp(difficulty, AI_MIN, AI_MAX);
  }
  function getMistakeRate(){
    const t = 1 - difficulty;
    return clamp(0.03 + t * 0.55, 0.03, 0.45);
  }

  // ✅ 10x10은 판이 작아서 후보 범위를 1칸로 줄여 속도/자연스러움 개선
  function genCandidates(){
    const cand = [];
    let hasStone = false;
    const mark = Array.from({length: SIZE}, () => Array(SIZE).fill(false));

    for(let y=0;y<SIZE;y++){
      for(let x=0;x<SIZE;x++){
        if(board[y][x] !== 0){
          hasStone = true;
          for(let dy=-1; dy<=1; dy++){
            for(let dx=-1; dx<=1; dx++){
              const nx=x+dx, ny=y+dy;
              if(inRange(nx,ny) && board[ny][nx]===0) mark[ny][nx] = true;
            }
          }
        }
      }
    }
    if(!hasStone){
      const c = Math.floor(SIZE/2);
      const starts = [
        {x:c,y:c},{x:c-1,y:c},{x:c,y:c-1},{x:c-1,y:c-1}
      ].filter(m => inRange(m.x,m.y));
      return starts;
    }
    for(let y=0;y<SIZE;y++) for(let x=0;x<SIZE;x++) if(mark[y][x]) cand.push({x,y});
    return cand;
  }

  function maxLineIfPlace(x,y,p){
    const dirs = [[1,0],[0,1],[1,1],[1,-1]];
    let best = 1;
    for(const [dx,dy] of dirs){
      const line = 1 + countDir(x,y,dx,dy,p) + countDir(x,y,-dx,-dy,p);
      if(line > best) best = line;
    }
    return best;
  }

  function scoreMove(x,y){
    const aiLine = maxLineIfPlace(x,y,AI);
    const plLine = maxLineIfPlace(x,y,PLAYER);

    const c = (SIZE-1)/2;
    const dist = Math.abs(x-c) + Math.abs(y-c);
    const centerScore = (SIZE*2 - dist);

    let score = 0;

    if(aiLine >= 5) score += 100000;
    else if(aiLine === 4) score += 2500;
    else if(aiLine === 3) score += 450;
    else if(aiLine === 2) score += 70;

    if(plLine >= 5) score += 90000;
    else if(plLine === 4) score += 2300;
    else if(plLine === 3) score += 420;
    else if(plLine === 2) score += 55;

    score += centerScore * 3;

    if(lastMove){
      const dx = Math.abs(x - lastMove.x);
      const dy = Math.abs(y - lastMove.y);
      const near = Math.max(0, 5 - (dx+dy));
      score += near * 8;
    }

    return score;
  }

  function findForcedMove(p){
    const cand = genCandidates();
    for(const m of cand){
      board[m.y][m.x] = p;
      const win = isWin(m.x, m.y, p);
      board[m.y][m.x] = 0;
      if(win) return m;
    }
    return null;
  }

  function rankMoves(){
    const cand = genCandidates();
    const ranked = cand.map(m => ({...m, score: scoreMove(m.x,m.y)}));
    ranked.sort((a,b) => b.score - a.score);
    return ranked;
  }

  function chooseAIMove(){
    const winMove = findForcedMove(AI);
    if(winMove) return winMove;

    const blockMove = findForcedMove(PLAYER);
    if(blockMove) return blockMove;

    const ranked = rankMoves();
    if(!ranked.length) return null;

    const doMistake = Math.random() < getMistakeRate();
    if(!doMistake) return { x: ranked[0].x, y: ranked[0].y };

    const widen = Math.floor((1 - difficulty) * MAX_SOFT_CHOICE);
    const maxIdx = clamp(1 + widen, 1, Math.min(MAX_SOFT_CHOICE, ranked.length)) - 1;
    const pick = Math.floor(Math.random() * (maxIdx + 1));
    return { x: ranked[pick].x, y: ranked[pick].y };
  }

  // =========================
  // 게임 진행
  // =========================
  function endGame(playerWon){
    gameOver = true;
    results.push(playerWon ? "W" : "L");
    results = results.slice(-10);
    adjustDifficulty();
    saveState();
  }

  function place(x,y,who){
    if(gameOver) return false;
    if(board[y][x] !== 0) return false;

    board[y][x] = who;
    lastMove = { x, y, player: who };
    draw();

    if(isWin(x,y,who)){
      setMsg(`${nameOf(who)} 승리!`);
      endGame(who === PLAYER);
      return true;
    }
    if(isDraw()){
      gameOver = true;
      setMsg("무승부!");
      saveState();
      return true;
    }
    return true;
  }

  function nextTurn(){
    turn = (turn === PLAYER) ? AI : PLAYER;
    setTurnUI();

    if(gameOver) return;

    if(turn === AI){
      setMsg("멧봉이…");
      setTimeout(() => {
        if(gameOver) return;
        const m = chooseAIMove();
        if(!m){
          setMsg("다시하기!");
          return;
        }
        place(m.x, m.y, AI);
        if(!gameOver){
          turn = PLAYER;
          setTurnUI();
          setMsg("여봉이 차례!");
        }
      }, 150);
    }else{
      setMsg("여봉이 차례!");
    }
  }

  function resetBoard(){
    board = Array.from({ length: SIZE }, () => Array(SIZE).fill(0));
    gameOver = false;
    lastMove = null;
    turn = firstPlayer;
    setTurnUI();
    saveState();
    draw();

    if(turn === AI){
      setMsg("멧봉이 선공!");
      setTimeout(() => {
        const m = chooseAIMove();
        if(m){
          place(m.x, m.y, AI);
          if(!gameOver){
            turn = PLAYER;
            setTurnUI();
            setMsg("여봉이 차례!");
          }
        }
      }, 150);
    }else{
      setMsg("원하는 곳을 눌러 돌을 둬!");
    }
  }

  // =========================
  // 입력
  // =========================
  canvas.addEventListener("pointerdown", (e) => {
    e.preventDefault();
    if(gameOver){
      setMsg("다시하기 눌러!");
      return;
    }
    if(turn !== PLAYER) return;

    const {x,y} = pointerToCell(e.clientX, e.clientY);
    const ok = place(x,y,PLAYER);
    if(!ok) return;
    if(!gameOver) nextTurn();
  }, { passive:false });

  canvas.addEventListener("contextmenu", (e) => e.preventDefault());

  resetBtn.addEventListener("click", () => resetBoard());
  toggleFirstBtn.addEventListener("click", () => {
    firstPlayer = (firstPlayer === PLAYER) ? AI : PLAYER;
    saveState();
    resetBoard();
  });

  // =========================
  // 시작
  // =========================
  setTurnUI();
  drawGrid();
  resetBoard();
})();
</script>
</body>
</html>
